JSON.stringify(obj); -конвертира от стринг в JS обект.   ВАЖНО!!!!!!!!!!!!!!!!!!!!              JSON    може да се запазва в отделен файл

JSON.parse(str); конвертира JS обекта в стринг.    ВАЖНО!!!!!!!!!!!!!!!!!!!!                        {JSON}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
entries - 
Превръща обекта в масив. Като се запазва обекта и се създава нов масив съдържащ обекта.   НЕ Е ПОЛЕЗНО!
Object.entries(person);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
keys  - връща масив от всички ключове на обекта!!!!             на 1:25:00 от лекцията се раюглежда масива. //  https://www.youtube.com/watch?time_continue=923&v=QMhtA1IF9H4&feature=emb_title
Object.keys()
За итерация по ключовете използваме for in loop ма като гледам също for each loops
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
values  - връща масив от всички стойности на обекта!!!!
Object.values() - 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Destructuring assignment от ES6.  Проблем с браузерите заради новите версии. които го поддържат.
за да не пишем от мързел.
var number;
var letter;
const arr = [7, 'k', 78,'Pesho'];
number=arr[0];
letter=arr[1];

Пишем:
var [number, letter] = arr;
console.log(number, letter);           връща 7 'k'
-------------------------------
var [ ,number, , letter] = arr;
console.log(number, letter);     връща k Pesho    втория и четвъртия елемент.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Обектите ги превръщаме в обекти и ги обхождаме с for of цикъл .
function solve(){
const person = {
firstName: "Peter",
lastName: "Pan",
age: "20"
};

let entries= Object.entries(person);

for(const [key, value] of entries) {
console.log(`${key}: ${value}`);
}
}
solve();
втъща:
firstName: Peter
lastName: Pan
Age: 20
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
JSON.stringify(object)
let text = JSON.stringify(obj);   // вече обекта губи свойствата на такъв и става текст. 

Можем да конвертураме JSON от стринг в обект, използвайки: JSON.parse(text)        - става жив обект, с който можем да работим и да променяме.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
При липса на стойности в обекта JS заменя празните стойности с ключовете с цел избягване на резултати като: undefinied
function convertJSON(name, lastName, hairColor) {    let person = {
        name,
        lastName,
        hairColor
	};
    console.log(JSON.stringify(person));
}                                                                                  //получаваме

function solve(name, lastName, hairColor) {
const person = {
        name : name,
        lastName : lastName,
        hairColor : hairColor
	};
    console.log(JSON.stringify(person));
}
solve("George", "Petrov", "blond");      //получаваме { "firstName": "George", "lastName": "Petrov", "hairColor": "blond" }
                   // ако в console.log не е обработено с JSON.stringify - ще получим този запис без кавички и джъдж ще изреве. //{ firstName: 'George', lastName: 'Petrov', hairColor: `blond` }
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class !!!   КОНСТРУКЦИЯ ЗА СЪЗДАВАНЕ НА КЛАСОВЕ.

class Student {
  constructor(name, grade) {             //РЕЗУЛТАТА КОЙТО ВРЪЩА КОНСТРУКТОРФУНКЦИЯТА Е НОВОСЪЗДАДЕНИЯ ОБЕКТ. ТЯ ВИНАГИ ВРЪЩА РЕЗУЛТАТ КАТО "RETURN''
    this.name = name;
    this.grade = grade;
  }
}
let student = new Student( 'Peter', 5.50);
------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------
вход:    arr- ['Sofia | 42.696552 | 23.32601',
                  'Beijing | 39.913818 | 116.363625'];

for (const row of arr) {
    const [town, latitude ,longitude] = row.split(' | ');
    
console.log(town,latitude ,longitude)

записа връща едновременно стойностите и за трите ключа като ги разпределя. Резултата е: (ВАЖНО! ПОЛУЧЕНИЯ РЕЗУЛТАТ НЕ Е МАСИВ, ВЪПРЕКИ ЧЕ Е В КВАДРАТНИ СКОБИ)
Sofia 42.696552 23.32601                                                            Със записа се казва, че винаги първия индекс ще ми е "town", втория ще бъде "latitude", третия ще бъде "longitude".
Beijing 39.913818 116.363625                                                  При липса на графа в някоя стойност, тя връща undefinied
Супер е!
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ако искам да достигна някой елемент на обекта:
store.beer- но ако това е променлива пишем:
store[product]

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

if(store.hasOwnProperty(product))   -  hasOwnProperty - ПРОВЕРЯВА ДАЛИ ИМЕТО от (product) конкретно за итерацията се съдържа в обекта!!!

  или sofia. hasOwnProperty(`name`)  //проверява в обекта sofia дали има ключ "name" ;
Другия начин е с проверка:
if(sofia.age === undenfined)
   console.log("Key 'age' does not exist'')
if(sofia.name !== undefined)
   console.log("Key `name` exists");
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Оператора "." във обекти, е както за добавяне, така и за заместване.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Когато получим обекта в стринг веднага го минаваме към числоо с JSON.parse(); за да може да е годен за работа.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
for in цикъла върти стойностите по индекс (на дълбоко) for of върти стойностите - по- навън.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
СТЕК- ТРУПАЩ ЕДНА СЛЕД ДРУГА ДАННИ И МОЖЕ ДА ДОСТЪПИШ САМО ТАЗИ НАЙ- ОТГОРЕ И НАДОЛУ ПОД РЕД.
ОПАШКА- ТРУПАТ СЕ ДАННИ И СЕ ВЗЕМАТ ПО РЕДА НА ПРИЕМАНЕ КАТО В МАГАЗИН. 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
map !!!!     РАботи като цикъл! Минава през всеки елемент.
map - Функцията създава нов масив и не променя нашия. 
[1,2.3.4] - първия масив arr!
map1 = arr.map(el => el*2);
map1= [2,4,6,8]   - това е новия масив, като е извършено действието *2 на всеки индекс и е прехвърлено на мястото
му в новия масив. 

При конвертиране от стринг номер: converedArr= arr.map(+el) но е по- правилно да се напише:
converedArr= arr.map(Number);  Number се пише така, защото е конструктор функция. 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
concat !!!      съединява двата масива! 
let arr = [1,2];

let length = arr.concat([3,4,5]);
length = [1,2,3,4,5]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
filter !!! работи с функции които имат 2 отговора - true или false.  РАботи като цикъл! Минава през всеки елемент.
let arr = [ 9, 2, 8, 6, 98];
let removed = arr.filter(x => x >7); 
Запазва се стария масив като се създава и нов с филтрираните стойности отговарящи на критериите.
[9, 8, 98] - тези елементи които изпълняват true се включват в новия масив, тези които изпълняват false не се вкл.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
sort !!!  алгоритмуването не работи коректно. За масив: let arr = [9, 2 ,8, 6, 98, 1000];  Сорт е функция, която променя масива!!!
Пишем: let sorted = arr.sort((a,b) => a - b);      // Ако се запише :b-a - ще сортира в обратен ред.
Получаваме подредения масив [ 2, 6, 8, 9, 98, 1000 ]
Ако не искаме да променяме масива може да се комбинира със slice  и да се направи сортирано копие на масива.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
REDUCE, MAP, FILTER, SORT ,SPLIT-,,REVERSE ,, ПОДОБРЕНИЕ!!!
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
join - превтъща масив в стринг.  splitovete = ["alpha", "beta"," gamma", "beta"]
splitovete.join("-"));
връща стринг-   "alpha-beta-gamma-beta"


от масив [-2, 7, 8, 9]
    console.log(res.join('\n')) - връща на отделни редове:  -2
                                                                                        7
                                                                                        8
                                                                                        9
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
push - променя масива!
let arr= [1, 2];

let length = arr.push([3, 4, 5])
console.log(arr)   връша [1, 2, 3, 4, 5]
console.log(length);  Връща дължината на модифицирания масив. 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
concat !!! Функцията обединява два масива.
let arr= [1, 2];

let length = arr.push(3, 4, 5)
console.log(arr)   връша [1, 2] запазило е оригиналния масив.
console.log(length);  [1, 2, 3, 4, 5]  връща обединения масив.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    let personNameKey = "firstName"
    personNameKey = "lastName"
    
    person[personNameKey] = name; // още един начин за деклариране на ключ с него може да се променя ключовата стойност!
    personNameKey = "lastName"


    console.log(person);

}
solve("Peter",
    "Pan",
    "20")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function solve(arr1, arr2) {
    let store = {};

    function products(arr) {
        let good = "";
        let quantity = 0;

        for (let i = 0; i < arr.length; i += 2) {
            good = arr[i];
            quantity = arr[i + 1];
            if (store[good]) {
                store[good] += Number(quantity)
            } else {
                store[good] = Number(quantity)
            }

        }
    }
    products(arr1)
    products(arr2)
console.log(store);

}
solve([
        'Chips', '5', 'CocaCola', '9', 'Bananas', '14', 'Pasta', '4', 'Beer', '2'
    ],
    [
        'Flour', '44', 'Oil', '12', 'Pasta', '7', 'Tomatoes', '70', 'Bananas', '30'
    ])
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
let person = {
       "name" : "Pesho",
        age : 18;
}
console.log(person.name);         //expexted output: Pesho
console.log(person["name"]);      //expexted output: Pesho - различен синтаксис, кавичките са задължителни!
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Никога не използваме "delete " в обекта - прави го бавен и е възможно да го счупи. За премахване на елементи
използваме MAP и REDUCE.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
let person = {                                             /Object - глобален обект, чрез който достъпваме ключовете в обекта, както е 
    "name": "Pesho",                                  // описано в примера.
    age: 18
};

let keys = Object.keys(person);

console.log(person[keys[0]]);    //expected result Pesho
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Ако имаме ключ,  който е от две думи
let person = {
    "first name": "Pesho",
    age: 18
};

let keys = Object.keys(person);

console.log(person);    //expected result//     {'first name': 'Pesho',age:18 }
Ако тръгна да достъпвам с: person.First name // не е възможно да се достъпи така, а само с:
person["First name"];
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
freeze  - Използва се при плъгини и контроли!

let person = {
    "firstName": "Pesho",
    age: 18
};
Object.freeze(person);

person.city = "Sofia";

console.log(person);    // //expected result {'first name': 'Pesho',age:18 } // иначе казано freeze замръзява обекта и не може 
да добавяме или да трием елементи. Става read only.

Проверка за замръзен обект:
console.log(Object.isFrozen(person));    //expected result: true
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
seal - когато обекта е в този "режим" може да се променят само стойности на негови обекти, не може да се добавят нови
ключове. Използва се при плъгини и контроли!

let person = {
    "firstName": "Pesho",
    age: 18
};
Object.seal(person);
person.firstName = "Sofia";         //Да мога да променям стойността на firstName
person.city = "ZZZ"                      // не, не мога да добавям нови стойности - не излиза в резултата.
console.log(person)                  expected output: {'first name': 'Sofia',age:18 }
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
